generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// System User with authentication details
model User {
  id        String  @id @default(uuid()) @db.Uuid
  email     String  @unique
  username  String? @unique
  password  String // Hashed password
  firstName String?
  lastName  String?
  fullName  String? // Keeping for backward compatibility or computed use
  isActive  Boolean @default(true)

  userRoles          UserRole[]
  stockMovements     StockMovement[]
  warehouseTransfers WarehouseTransfer[]
  purchaseOrders     PurchaseOrder[]
  deliveries         Delivery[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

/// Roles implementation (e.g. Admin, Manager, Seller)
model Role {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @unique
  description String?

  permissions RolePermission[]
  users       UserRole[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("roles")
}

/// Granular permissions (e.g. inventory.create, reports.view)
model Permission {
  id          String  @id @default(uuid()) @db.Uuid
  action      String  @unique
  description String?

  roles RolePermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("permissions")
}

/// Many-to-many relationship betweeen Users and Roles
model UserRole {
  id     String @id @default(uuid()) @db.Uuid
  userId String @db.Uuid
  roleId String @db.Uuid

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, roleId])
  @@map("user_roles")
}

/// Many-to-many relationship between Roles and Permissions
model RolePermission {
  id           String @id @default(uuid()) @db.Uuid
  roleId       String @db.Uuid
  permissionId String @db.Uuid

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([roleId, permissionId])
  @@map("role_permissions")
}

/// Warehouse/Deposit location for inventory storage
model Warehouse {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @unique
  code        String  @unique // Short code like "WH-01", "DEP-A"
  description String?
  address     String?
  isActive    Boolean @default(true)

  stockItems     WarehouseStock[]
  stockMovements StockMovement[]
  transfersFrom  WarehouseTransfer[] @relation("TransferFrom")
  transfersTo    WarehouseTransfer[] @relation("TransferTo")
  purchaseOrders PurchaseOrder[]
  deliveries     Delivery[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("warehouses")
}

/// Stock quantity per product per warehouse
model WarehouseStock {
  id          String @id @default(uuid()) @db.Uuid
  warehouseId String @db.Uuid
  productId   String @db.Uuid
  quantity    Int    @default(0)

  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([warehouseId, productId])
  @@map("warehouse_stock")
}

/// Status of warehouse transfer operations
enum TransferStatus {
  PENDING
  IN_TRANSIT
  COMPLETED
  CANCELLED
}

/// Transfers between warehouses
model WarehouseTransfer {
  id              String         @id @default(uuid()) @db.Uuid
  fromWarehouseId String         @db.Uuid
  toWarehouseId   String         @db.Uuid
  productId       String         @db.Uuid
  quantity        Int
  status          TransferStatus @default(PENDING)
  notes           String?

  fromWarehouse Warehouse @relation("TransferFrom", fields: [fromWarehouseId], references: [id])
  toWarehouse   Warehouse @relation("TransferTo", fields: [toWarehouseId], references: [id])
  product       Product   @relation(fields: [productId], references: [id])

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id])

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@map("warehouse_transfers")
}

/// Supplier information and contact details
model Supplier {
  id          String  @id @default(uuid()) @db.Uuid
  name        String
  code        String  @unique
  email       String?
  phone       String?
  address     String?
  contactName String?
  notes       String?
  isActive    Boolean @default(true)

  purchaseOrders PurchaseOrder[]
  products       Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("suppliers")
}

/// Status of purchase orders
enum PurchaseOrderStatus {
  DRAFT
  PENDING
  RECEIVED
  PARTIAL
  CANCELLED
}

/// Purchase orders from suppliers
model PurchaseOrder {
  id           String              @id @default(uuid()) @db.Uuid
  orderNumber  String              @unique
  supplierId   String              @db.Uuid
  warehouseId  String              @db.Uuid
  status       PurchaseOrderStatus @default(DRAFT)
  orderDate    DateTime            @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  notes        String?
  totalAmount  Decimal             @db.Decimal(10, 2)

  supplier  Supplier            @relation(fields: [supplierId], references: [id])
  warehouse Warehouse           @relation(fields: [warehouseId], references: [id])
  items     PurchaseOrderItem[]

  createdById String @db.Uuid
  createdBy   User   @relation(fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("purchase_orders")
}

/// Items in a purchase order
model PurchaseOrderItem {
  id              String  @id @default(uuid()) @db.Uuid
  purchaseOrderId String  @db.Uuid
  productId       String  @db.Uuid
  quantity        Int
  receivedQty     Int     @default(0)
  unitPrice       Decimal @db.Decimal(10, 2)

  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product       Product       @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("purchase_order_items")
}

/// Institution that receives deliveries
model Institution {
  id          String  @id @default(uuid()) @db.Uuid
  name        String
  code        String  @unique
  type        String? // e.g., "School", "Hospital", "Charity"
  contactName String?
  email       String?
  phone       String?
  address     String?
  notes       String?
  isActive    Boolean @default(true)

  deliveries Delivery[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("institutions")
}

/// Status of delivery operations
enum DeliveryStatus {
  DRAFT
  CONFIRMED
  DELIVERED
  CANCELLED
}

/// Deliveries to institutions
model Delivery {
  id             String         @id @default(uuid()) @db.Uuid
  deliveryNumber String         @unique
  institutionId  String         @db.Uuid
  warehouseId    String         @db.Uuid
  status         DeliveryStatus @default(DRAFT)
  deliveryDate   DateTime?
  receivedBy     String? // Person who received the delivery
  notes          String?

  institution Institution    @relation(fields: [institutionId], references: [id])
  warehouse   Warehouse      @relation(fields: [warehouseId], references: [id])
  items       DeliveryItem[]

  createdById String @db.Uuid
  createdBy   User   @relation(fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("deliveries")
}

/// Items in a delivery
model DeliveryItem {
  id         String @id @default(uuid()) @db.Uuid
  deliveryId String @db.Uuid
  productId  String @db.Uuid
  quantity   Int

  delivery Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("delivery_items")
}

model Category {
  id          String    @id @default(uuid()) @db.Uuid
  name        String    @unique
  description String?
  products    Product[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("categories")
}

model Product {
  id          String  @id @default(uuid()) @db.Uuid
  sku         String  @unique
  name        String
  description String?
  price       Decimal @db.Decimal(10, 2)
  unit        String  @default("U") // Unidad de medida (U, Kg, L, m, etc.)
  stock       Int     @default(0)
  minStock    Int     @default(0)

  // Datos de compra/recepción
  purchaseCode    String?   // Código/ID de Compra (ej: 2018/224/25)
  purchaseDate    DateTime? // Fecha de compra
  purchaseAmount  Decimal?  @db.Decimal(10, 2) // Monto total de la compra
  destination     String?   // Destino/Responsable (ej: "Automotores - Luis Caro")
  receiptImageUrl String?   // URL de la imagen del comprobante

  categoryId String?   @db.Uuid
  category   Category? @relation(fields: [categoryId], references: [id])

  // Relación opcional con proveedor
  supplierId String?   @db.Uuid
  supplier   Supplier? @relation(fields: [supplierId], references: [id])

  movements          StockMovement[]
  warehouseStock     WarehouseStock[]
  warehouseTransfers WarehouseTransfer[]
  purchaseOrderItems PurchaseOrderItem[]
  deliveryItems      DeliveryItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("products")
}

enum MovementType {
  IN
  OUT
  ADJUSTMENT
}

model StockMovement {
  id        String  @id @default(uuid()) @db.Uuid
  productId String  @db.Uuid
  product   Product @relation(fields: [productId], references: [id])

  warehouseId String?    @db.Uuid
  warehouse   Warehouse? @relation(fields: [warehouseId], references: [id])

  type     MovementType
  quantity Int
  reason   String?

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())

  @@map("stock_movements")
}
